> I have RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET in my environment. I want to build a payment system and 
  implement RBAC so that I can offer a single Pro subscription tier at ₹100 per month. This is the only 
  subscription we offer. Can you help me plan this implementation? Specifically, I want to know what new API 
  routes and frontend components we should create, where the "Upgrade to Pro" button should be placed (what's 
  the most sensible spot?), and how to enforce RBAC so that some features—like GitHub import—are restricted to 
  Pro users only. I also want to know what new MongoDB collections we’d need and how the data model should be 
  designed, along with the reasoning behind it. Please provide a project folder structure update to accommodate
   these changes. Finally, give me a complete flow of implementation: how we handle subscriptions, payments, 
  and feature access, while also explaining relevant Razorpay concepts like orders, subscriptions, and 
  webhooks, so I can understand both the technical steps and the concepts behind them. No code edits—just clear
   design, structure, and explanation.

⏺ I'll help you design a comprehensive payment system with RBAC for your Pro subscription tier. Let me start by
   examining your current codebase structure to understand the existing architecture.

⏺ Update Todos
  ⎿  ☐ Analyze current codebase structure and architecture         
     ☐ Design MongoDB collections and data models for subscriptions
     ☐ Plan API routes for payment and subscription management
     ☐ Design frontend components and UI placement strategy
     ☐ Design RBAC system for feature access control
     ☐ Create updated project folder structure
     ☐ Document complete implementation flow and Razorpay concepts

⏺ Based on my analysis of your codebase, I'll provide a comprehensive design for implementing a payment system
  with RBAC for your Pro subscription tier. Here's the complete plan:

  MongoDB Collections & Data Models

  1. Subscription Collection

  {
    _id: ObjectId,
    userId: ObjectId, // Reference to User collection
    razorpaySubscriptionId: String, // Razorpay subscription ID
    razorpayCustomerId: String, // Razorpay customer ID
    planId: String, // "pro_monthly" 
    status: String, // "active", "cancelled", "past_due", "unpaid"
    currentPeriodStart: Date,
    currentPeriodEnd: Date,
    createdAt: Date,
    updatedAt: Date,
    cancelledAt: Date, // null if active
    metadata: Object // Additional subscription data
  }

  2. Payment Collection

  {
    _id: ObjectId,
    userId: ObjectId,
    subscriptionId: ObjectId, // Reference to Subscription
    razorpayPaymentId: String,
    razorpayOrderId: String,
    amount: Number, // in paise (₹100 = 10000)
    currency: String, // "INR"
    status: String, // "created", "authorized", "captured", "refunded", "failed"
    method: String, // "card", "netbanking", "wallet", "upi"
    createdAt: Date,
    updatedAt: Date
  }

  3. Updated User Model

  // Add to existing User schema:
  {
    subscriptionTier: {
      type: String,
      enum: ["free", "pro"],
      default: "free"
    },
    subscriptionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Subscription',
      default: null
    }
  }

  Reasoning: Separate collections allow for detailed payment tracking, audit trails, and easier subscription
  management. The User model gets minimal updates to avoid breaking changes.

⏺ API Routes Architecture

  Payment & Subscription Routes

  src/app/api/
  ├── subscription/
  │   ├── create/route.ts          # Create subscription
  │   ├── status/route.ts          # Get subscription status
  │   ├── cancel/route.ts          # Cancel subscription
  │   └── webhook/route.ts         # Razorpay webhooks
  ├── payment/
  │   ├── create-order/route.ts    # Create Razorpay order
  │   ├── verify/route.ts          # Verify payment
  │   └── history/route.ts         # Payment history
  └── user/
      ├── subscription/route.ts    # Get user subscription details
      └── upgrade/route.ts         # Upgrade to Pro

  Key Route Functions

  - /api/subscription/create: Creates Razorpay subscription and customer
  - /api/payment/create-order: Generates Razorpay order for payment
  - /api/payment/verify: Verifies payment signature and updates subscription
  - /api/subscription/webhook: Handles Razorpay webhooks for status updates
  - /api/user/subscription: Returns current user's subscription status

⏺ Frontend Components & UI Placement

  New Components to Create

  src/components/
  ├── subscription/
  │   ├── UpgradeModal.tsx         # Upgrade to Pro modal
  │   ├── PaymentForm.tsx          # Razorpay payment form
  │   ├── SubscriptionStatus.tsx   # Shows current plan
  │   └── ProBadge.tsx            # Pro user indicator
  ├── payment/
  │   ├── PaymentSuccess.tsx       # Success confirmation
  │   └── PaymentFailed.tsx        # Error handling
  └── ui/
      └── ProFeatureGate.tsx       # Wrapper for Pro-only features

  Strategic "Upgrade to Pro" Button Placement

  Most sensible locations based on your current UI:

  1. Sidebar (Primary placement) - src/components/chat/SideBar.tsx:317
    - Add between user auth section and theme toggle
    - Always visible, non-intrusive
    - Shows Pro status or upgrade option
  2. GitHub Import Modal (Secondary) - src/components/ui/GitHubImportModal.tsx:350
    - Gate the entire GitHub import feature for Pro users
    - Replace content with upgrade prompt for free users
  3. Chat Input Area (Contextual) - When users hit limits
    - Show upgrade prompt when free users exceed usage limits
    - Non-blocking but contextually relevant

  ProFeatureGate Component Pattern

  <ProFeatureGate feature="github-import" fallback={<UpgradePrompt />}>
    <GitHubImportModal />
  </ProFeatureGate>

⏺ RBAC System Design

  Permission-Based Access Control

  1. Role Definitions
  // src/lib/permissions.ts
  export const USER_ROLES = {
    FREE: 'free',
    PRO: 'pro'
  } as const;

  export const PERMISSIONS = {
    GITHUB_IMPORT: 'github:import',
    UNLIMITED_CHATS: 'chats:unlimited',
    PRIORITY_SUPPORT: 'support:priority',
    // Add more Pro features as needed
  } as const;

  export const ROLE_PERMISSIONS = {
    [USER_ROLES.FREE]: [],
    [USER_ROLES.PRO]: [
      PERMISSIONS.GITHUB_IMPORT,
      PERMISSIONS.UNLIMITED_CHATS,
      PERMISSIONS.PRIORITY_SUPPORT
    ]
  };

  2. Permission Checking Functions
  // src/lib/rbac.ts
  export function hasPermission(userRole: string, permission: string): boolean {
    const rolePermissions = ROLE_PERMISSIONS[userRole] || [];
    return rolePermissions.includes(permission);
  }

  export function requiresProSubscription(permission: string): boolean {
    return ROLE_PERMISSIONS[USER_ROLES.PRO].includes(permission);
  }

  3. API Route Protection
  // src/lib/middleware/auth.ts
  export async function withRBAC(permission: string) {
    return async (req: NextRequest) => {
      const session = await getServerSession();
      const user = await getUserWithSubscription(session.user.id);

      if (!hasPermission(user.subscriptionTier, permission)) {
        return NextResponse.json(
          { error: 'Premium subscription required' },
          { status: 403 }
        );
      }
      // Continue to route handler
    };
  }

  4. Component-Level Guards
  // Usage in components
  const canUseGitHubImport = hasPermission(user?.subscriptionTier, PERMISSIONS.GITHUB_IMPORT);

  {canUseGitHubImport ? (
    <GitHubImportButton />
  ) : (
    <UpgradeToProButton feature="GitHub Import" />
  )}

⏺ Updated Project Structure

  bot-ai/
  ├── src/
  │   ├── app/
  │   │   ├── api/
  │   │   │   ├── payment/
  │   │   │   │   ├── create-order/route.ts
  │   │   │   │   ├── verify/route.ts
  │   │   │   │   └── history/route.ts
  │   │   │   ├── subscription/
  │   │   │   │   ├── create/route.ts
  │   │   │   │   ├── status/route.ts
  │   │   │   │   ├── cancel/route.ts
  │   │   │   │   └── webhook/route.ts
  │   │   │   ├── user/
  │   │   │   │   ├── subscription/route.ts
  │   │   │   │   └── upgrade/route.ts
  │   │   │   └── [existing routes...]
  │   │   ├── subscription/
  │   │   │   ├── success/page.tsx
  │   │   │   └── failed/page.tsx
  │   │   └── [existing pages...]
  │   ├── components/
  │   │   ├── subscription/
  │   │   │   ├── UpgradeModal.tsx
  │   │   │   ├── PaymentForm.tsx
  │   │   │   ├── SubscriptionStatus.tsx
  │   │   │   └── ProBadge.tsx
  │   │   ├── payment/
  │   │   │   ├── PaymentSuccess.tsx
  │   │   │   └── PaymentFailed.tsx
  │   │   ├── ui/
  │   │   │   ├── ProFeatureGate.tsx
  │   │   │   └── [existing components...]
  │   │   └── [existing components...]
  │   ├── lib/
  │   │   ├── razorpay.ts          # Razorpay client configuration
  │   │   ├── permissions.ts       # Role and permission definitions
  │   │   ├── rbac.ts             # RBAC utility functions
  │   │   ├── subscription.ts      # Subscription helper functions
  │   │   └── [existing files...]
  │   ├── server/
  │   │   ├── models/
  │   │   │   ├── Subscription.ts
  │   │   │   ├── Payment.ts
  │   │   │   ├── User.ts         # Updated with subscription fields
  │   │   │   └── [existing models...]
  │   │   └── middleware/
  │   │       └── auth.ts         # RBAC middleware
  │   ├── hooks/
  │   │   ├── useSubscription.ts   # Subscription state management
  │   │   └── [existing hooks...]
  │   └── types/
  │       ├── subscription.ts      # Subscription type definitions
  │       ├── payment.ts          # Payment type definitions
  │       └── [existing types...]
  └── [existing files...]

⏺ Complete Implementation Flow

  1. User Upgrade Journey

  Free User → Clicks "Upgrade to Pro" → Payment Modal → Razorpay Checkout → Success → Pro Features Unlocked

  Step-by-step:
  1. User clicks upgrade button in sidebar
  2. UpgradeModal opens with Pro benefits
  3. Calls /api/subscription/create to create Razorpay subscription
  4. PaymentForm renders Razorpay checkout
  5. User completes payment
  6. Razorpay redirects to success/failure pages
  7. Webhook updates subscription status in database
  8. User gains access to Pro features immediately

  2. Subscription Management Flow

  Active Subscription → Periodic Billing → Webhook Updates → Status Sync → Feature Access Maintained

  3. Feature Access Enforcement

  User Action → Permission Check → Allow/Deny → Show Feature/Upgrade Prompt

  Razorpay Concepts Explained

  Core Razorpay Objects

  1. Customer
  - Represents your user in Razorpay system
  - Stores billing info, payment methods
  - Required for subscriptions

  2. Plan
  - Defines subscription terms (₹100/month)
  - Created once in Razorpay dashboard
  - Referenced when creating subscriptions

  3. Subscription
  - Links customer to plan
  - Handles automatic billing
  - Has lifecycle: created → authenticated → active → cancelled

  4. Order
  - For one-time payments
  - Required before payment capture
  - Contains amount, currency, notes

  5. Payment
  - Actual transaction record
  - Links to order for one-time or subscription for recurring
  - Has signature for verification

  Key Razorpay Flows

  Subscription Creation:
  1. Create customer in Razorpay
  2. Create subscription with plan_id and customer_id
  3. Return subscription object to frontend
  4. Frontend initializes Razorpay with subscription_id

  Payment Verification:
  1. Frontend receives payment response
  2. Backend verifies signature using webhook secret
  3. Update subscription status in database
  4. Grant user Pro access

  Webhook Handling:
  - subscription.charged - Payment succeeded
  - subscription.cancelled - User cancelled
  - payment.failed - Payment failed
  - subscription.pending - Awaiting payment

  Security Considerations

  - Always verify Razorpay signatures
  - Use webhook secrets for authentication
  - Never trust frontend payment status
  - Implement idempotency for webhook handling
  - Store sensitive keys in environment variables

⏺ Implementation Priority & Next Steps

  Phase 1: Foundation (Week 1)

  1. Set up Razorpay configuration and create Pro plan
  2. Create database models (Subscription, Payment)
  3. Update User model with subscription fields
  4. Build core API routes for subscription management

  Phase 2: Payment Integration (Week 2)

  1. Implement Razorpay payment flow
  2. Build subscription and payment forms
  3. Set up webhook handling for status updates
  4. Create success/failure pages

  Phase 3: RBAC & UI (Week 3)

  1. Implement permission system
  2. Add upgrade buttons to strategic locations
  3. Gate GitHub import feature behind Pro subscription
  4. Build subscription management UI

  Phase 4: Polish & Testing (Week 4)

  1. Add subscription status indicators
  2. Implement cancellation flow
  3. Test webhook reliability
  4. Add proper error handling and loading states

  This design provides a scalable foundation that can easily accommodate additional Pro features and
  subscription tiers in the future. The RBAC system ensures clean feature gating, while the payment
  infrastructure handles all billing complexities through Razorpay's robust platform.

> How do we handle refunds in the flow? How do we reverse a transaction? What all edge cases do we need to 
  consider? Im new to this payment gateway, what all do you think I need to know. 
  How do we make this system robust? 
  Do we have to create all the subscription plans in the dashboard of razorpay? And then put the one’s we want 
  in the ui? Or how does this work? 
  Each month has a separate subscription id? 
  How are we enforcing rbac? Like on backend in db we have roles and permissions, are we sending these to 
  frontend ?are we storing these on frontend, if yes where, how? How does this flow look like? Where exactly 
  are we checking and enforcing these permissions.
  Which razorpay api is responsible for Create Customer? Create Subscription linked to Plan? Create plan? Why 
  do we need to return subscription id to frontend, what’s going on here?

✻ Thinking…

  The user is asking very detailed questions about the payment system implementation. They want to understand:

  1. Refunds and transaction reversal
  2. Edge cases to consider
  3. What they need to know as beginners to payment gateways
  4. Making the system robust
  5. How subscription plans work in Razorpay
  6. Subscription ID per month
  7. RBAC enforcement flow (backend to frontend)
  8. Specific Razorpay APIs
  9. Why return subscription ID to frontend

  These are excellent questions that show they want to understand the system deeply. I should provide 
  comprehensive answers with specific examples and flows.

  Let me structure this properly and add it to my todo list to track the responses.

⏺ Excellent questions! Let me break down each aspect comprehensively. These are crucial details for building a
  robust payment system.

⏺ Update Todos
  ⎿  ☐ Explain refunds and transaction reversal process     
     ☐ Detail edge cases and error handling
     ☐ Explain Razorpay plan creation and management
     ☐ Clarify subscription ID lifecycle and billing cycles
     ☐ Detail RBAC enforcement flow from backend to frontend
     ☐ Explain specific Razorpay APIs and their purposes
     ☐ Provide robust system design patterns

✻ Thinking…

  Let me address each of these questions systematically:

  1. Refunds and transaction reversal
  2. Edge cases  
  3. Razorpay beginner concepts
  4. Robust system design
  5. Plan creation and management
  6. Subscription ID lifecycle
  7. RBAC enforcement flow
  8. Specific Razorpay APIs

  I should provide concrete examples and code snippets where helpful.

⏺ 1. Refunds & Transaction Reversal

  Refund Process Flow

  // API Route: /api/payment/refund
  export async function POST(req: Request) {
    const { paymentId, amount, reason } = await req.json();

    // Create refund via Razorpay
    const refund = await razorpay.payments.refund(paymentId, {
      amount: amount, // Amount in paise, partial refund allowed
      speed: 'normal', // 'normal' or 'optimum'
      notes: { reason }
    });

    // Update database
    await Payment.findOneAndUpdate(
      { razorpayPaymentId: paymentId },
      {
        status: 'refunded',
        refundId: refund.id,
        refundAmount: amount,
        refundedAt: new Date()
      }
    );

    // Downgrade user if full refund
    if (amount === originalAmount) {
      await User.findByIdAndUpdate(userId, {
        subscriptionTier: 'free',
        subscriptionId: null
      });
    }
  }

  Refund Types

  - Full Refund: Complete amount returned, user downgraded immediately
  - Partial Refund: Pro-rated amount, subscription continues
  - Speed: normal (5-7 days) vs optimum (instant but higher fees)

  When Refunds Happen

  - Customer requests cancellation within grace period
  - Technical issues preventing service delivery
  - Compliance/dispute resolution
  - Failed subscription delivery

✻ Thinking…

  Let me continue with edge cases and error handling. This is crucial for a robust payment system.

⏺ 2. Critical Edge Cases & Error Handling

  Payment Edge Cases

  // Edge Case Handler
  class PaymentEdgeCaseHandler {
    // 1. Webhook arrives before frontend callback
    static async handleWebhookFirst(subscriptionId) {
      const subscription = await Subscription.findOne({ razorpaySubscriptionId: subscriptionId });
      if (!subscription) {
        // Store webhook data temporarily
        await WebhookQueue.create({
          subscriptionId,
          status: 'pending_user_creation',
          data: webhookData,
          retryCount: 0
        });
      }
    }

    // 2. Duplicate webhook handling (Idempotency)
    static async handleDuplicateWebhook(webhookId, subscriptionId) {
      const existing = await ProcessedWebhook.findOne({ webhookId });
      if (existing) {
        return { success: true, message: 'Already processed' };
      }

      await ProcessedWebhook.create({ webhookId, subscriptionId, processedAt: new Date() });
      // Continue processing...
    }

    // 3. Failed payment with active subscription
    static async handleFailedPayment(subscriptionId) {
      const subscription = await Subscription.findOne({ razorpaySubscriptionId: subscriptionId });

      // Grace period: 3 days
      const gracePeriodEnd = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);

      await Subscription.findByIdAndUpdate(subscription._id, {
        status: 'past_due',
        gracePeriodEnd
      });

      // Don't immediately downgrade - give grace period
      // Schedule job to check after grace period
      await ScheduleJob.create({
        type: 'check_grace_period',
        subscriptionId: subscription._id,
        executeAt: gracePeriodEnd
      });
    }
  }

  Database Edge Cases

  - Concurrent Updates: Use MongoDB transactions
  - Orphaned Records: Cleanup jobs for incomplete subscriptions
  - Data Inconsistency: Regular reconciliation with Razorpay
  - Network Timeouts: Retry mechanisms with exponential backoff

  User Experience Edge Cases

  - Browser Crash During Payment: Resume payment flow
  - Multiple Tab Payments: Prevent duplicate subscriptions
  - Expired Sessions: Refresh authentication before payment

✻ Thinking…

  Now let me address the Razorpay plan creation and management question. This is important because it affects 
  how the system is set up and managed.

⏺ 3. Razorpay Plan Creation & Management

  Yes, Create Plans in Razorpay Dashboard First

  Step 1: Create Plan in Razorpay Dashboard
  // This is done ONCE in Razorpay Dashboard or via API
  {
    "id": "plan_pro_monthly",
    "entity": "plan",
    "interval": 1,
    "period": "monthly",
    "item": {
      "id": "item_pro_subscription",
      "name": "Bot AI Pro Monthly",
      "description": "Premium AI features including GitHub import",
      "amount": 10000, // ₹100 in paise
      "currency": "INR"
    }
  }

  Step 2: Store Plan IDs in Your Code
  // src/config/subscription-plans.ts
  export const SUBSCRIPTION_PLANS = {
    PRO_MONTHLY: {
      id: 'plan_pro_monthly', // From Razorpay dashboard
      name: 'Pro Monthly',
      price: 10000, // ₹100 in paise
      currency: 'INR',
      features: [
        'GitHub Repository Import',
        'Unlimited Chat History',
        'Priority Support'
      ]
    }
    // Future plans can be added here
  } as const;

  Step 3: UI Displays Your Configured Plans
  // Component shows what YOU decide to offer
  function PricingPlans() {
    return (
      <div>
        {Object.values(SUBSCRIPTION_PLANS).map(plan => (
          <PricingCard 
            key={plan.id}
            plan={plan}
            onSubscribe={() => createSubscription(plan.id)}
          />
        ))}
      </div>
    );
  }

  Why This Approach?

  - Control: You decide which plans to offer in UI
  - Flexibility: Can have plans in Razorpay but not show them
  - Testing: Create test plans without affecting production UI
  - Compliance: Plans need Razorpay approval for certain features

✻ Thinking…

  Now let me clarify the subscription ID lifecycle, which seems to be confusing. The user is asking if each 
  month has a separate subscription ID, which is not correct - one subscription ID handles all recurring 
  billing.

⏺ 4. Subscription ID Lifecycle & Billing Cycles

  ❌ MISCONCEPTION: Each month ≠ separate subscription ID

  ✅ CORRECT: One subscription ID handles ALL billing cycles

  // Example Subscription Lifecycle
  {
    "id": "sub_ABC123XYZ", // SAME ID for entire subscription lifecycle
    "plan_id": "plan_pro_monthly",
    "customer_id": "cust_USER123",
    "status": "active",
    "current_start": "2024-01-15", // Current billing period start
    "current_end": "2024-02-15",   // Current billing period end
    "charge_at": "2024-02-15",     // Next billing date
    "total_count": 12,             // Total payments made so far
    // This SAME subscription will bill again on Feb 15, Mar 15, etc.
  }

  How Billing Cycles Work

  // Timeline for subscription "sub_ABC123XYZ"
  Month 1: Jan 15 → Feb 15  (Payment 1: ₹100) ✅
  Month 2: Feb 15 → Mar 15  (Payment 2: ₹100) ✅
  Month 3: Mar 15 → Apr 15  (Payment 3: ₹100) ✅
  // Same subscription ID throughout!

  // Each payment gets a unique payment ID
  Payment IDs: pay_001, pay_002, pay_003...
  Subscription ID: sub_ABC123XYZ (CONSTANT)

  Database Tracking

  // Your Subscription collection
  {
    _id: ObjectId("..."),
    razorpaySubscriptionId: "sub_ABC123XYZ", // Never changes
    currentPeriodStart: "2024-03-15",
    currentPeriodEnd: "2024-04-15",
    status: "active",
    totalPayments: 3
  }

  // Your Payment collection (multiple records)
  [
    { razorpayPaymentId: "pay_001", subscriptionId: ObjectId("..."), amount: 10000 },
    { razorpayPaymentId: "pay_002", subscriptionId: ObjectId("..."), amount: 10000 },
    { razorpayPaymentId: "pay_003", subscriptionId: ObjectId("..."), amount: 10000 }
  ]

✻ Thinking…

  Now let me detail the RBAC enforcement flow from backend to frontend. This is a crucial security concept that
   the user needs to understand clearly.

⏺ 5. RBAC Enforcement Flow: Backend → Frontend

  🔒 Security Rule: NEVER trust frontend for permissions

  Complete RBAC Flow

  Step 1: Backend Database (Source of Truth)
  // Database stores the authority
  User: {
    subscriptionTier: "pro", // or "free" 
    subscriptionId: ObjectId("...")
  }

  Step 2: API Route Protection (Server-Side)
  // /api/github/import/route.ts
  export async function POST(req: Request) {
    const session = await getServerSession(authOptions);

    // ALWAYS check permissions on server
    const user = await User.findById(session.user.id);
    if (user.subscriptionTier !== 'pro') {
      return NextResponse.json({ error: 'Pro subscription required' }, { status: 403 });
    }

    // Only proceed if authorized
    return handleGitHubImport(req);
  }

  Step 3: Session Enhancement (Backend → Frontend)
  // src/lib/auth.ts - NextAuth callback
  callbacks: {
    async session({ session, user }) {
      if (session.user) {
        session.user.id = user.id;

        // Fetch fresh subscription data
        const userData = await User.findById(user.id)
          .populate('subscriptionId')
          .lean();

        session.user.subscriptionTier = userData.subscriptionTier;
        session.user.permissions = getPermissionsForTier(userData.subscriptionTier);
      }
      return session;
    }
  }

  Step 4: Frontend Permission Checking (UX Only)
  // Component level - FOR UX, NOT SECURITY
  function GitHubImportButton() {
    const { data: session } = useSession();

    // This is ONLY for showing/hiding UI
    const canImport = session?.user?.permissions?.includes('github:import');

    if (!canImport) {
      return <UpgradeToProButton />;
    }

    return <GitHubImportModal />; // API will still verify permissions
  }

  Where Permissions Are Stored & Checked

  ❌ Frontend Storage (Insecure)
  // NEVER store permissions in:
  localStorage.setItem('userPermissions', '...'); // ❌ Hackable
  cookies.set('isProUser', 'true'); // ❌ Modifiable  

  ✅ Secure Flow
  // 1. Database (Source of Truth)
  MongoDB User.subscriptionTier = "pro"

  // 2. Session (Temporary, Server-Controlled)  
  NextAuth session.user.permissions = ["github:import", ...]

  // 3. API Validation (Every Request)
  if (user.subscriptionTier !== 'pro') return 403;

  Multi-Layer Permission Checking

  // Layer 1: Component (UX)
  const showFeature = hasPermission(session.user.permissions, 'github:import');

  // Layer 2: API Route (Security)
  const user = await User.findById(userId);
  if (!hasPermission(user.subscriptionTier, 'github:import')) {
    throw new Error('Unauthorized');
  }

  // Layer 3: Database Query (Data)
  const result = await Chat.find({
    userId,
    // Only show pro features if user is pro
    ...(user.subscriptionTier === 'pro' ? {} : { isProFeature: false })
  });

✻ Thinking…

  Now let me explain the specific Razorpay APIs and their purposes. This is important for the user to 
  understand the technical implementation details.

⏺ 6. Specific Razorpay APIs & Their Purposes

  Core API Endpoints You'll Use

  1. Create Customer API
  // razorpay.customers.create()
  const customer = await razorpay.customers.create({
    name: user.name,
    email: user.email,
    contact: user.phone, // optional
    notes: {
      userId: user.id.toString()
    }
  });
  // Returns: { id: "cust_ABC123", email: "...", ... }
  // Purpose: Creates Razorpay customer for billing management

  2. Create Subscription API
  // razorpay.subscriptions.create()
  const subscription = await razorpay.subscriptions.create({
    plan_id: "plan_pro_monthly", // Pre-created in dashboard
    customer_id: customer.id,
    total_count: 12, // Optional: limit to 12 months
    notes: {
      userId: user.id.toString()
    }
  });
  // Returns: { id: "sub_XYZ789", status: "created", ... }
  // Purpose: Links customer to billing plan

  3. Fetch Subscription API
  // razorpay.subscriptions.fetch()
  const subscription = await razorpay.subscriptions.fetch(subscriptionId);
  // Returns: Current subscription status, billing dates, payment info
  // Purpose: Check subscription status, sync with your database

  Why Return Subscription ID to Frontend?

  The Razorpay Flow Requires It:
  // Backend creates subscription → Returns ID to frontend
  const subscription = await razorpay.subscriptions.create({...});
  return { subscriptionId: subscription.id }; // Frontend needs this

  // Frontend uses ID to initialize Razorpay checkout
  const rzp = new Razorpay({
    key: 'rzp_test_...',
    subscription_id: subscriptionId, // ← Required by Razorpay
    handler: function(response) {
      // Handle successful payment
    }
  });

  Complete API Flow

  // Step 1: Create Customer (if doesn't exist)
  const customer = await razorpay.customers.create({...});

  // Step 2: Create Subscription  
  const subscription = await razorpay.subscriptions.create({
    plan_id: "plan_pro_monthly",
    customer_id: customer.id
  });

  // Step 3: Return to frontend for payment
  return { subscriptionId: subscription.id };

  // Frontend: Initialize Razorpay with subscription_id
  // User pays → Razorpay processes → Webhooks notify your server
  // Step 4: Webhook handling
  webhook: subscription.charged → Update user to Pro in your DB

  Payment vs Subscription APIs

  One-time Payment (Not for your use case):
  // For single payments - you DON'T need this for subscriptions
  razorpay.orders.create() // Creates order
  razorpay.payments.fetch() // Gets payment status

  Subscription Payment (Your use case):
  // Razorpay handles recurring billing automatically
  // You only need to:
  1. Create subscription once
  2. Handle webhooks for status updates
  3. Use subscriptions.fetch() to sync status

✻ Thinking…

  Finally, let me provide robust system design patterns to make the payment system reliable and maintainable.

⏺ 7. Making the System Robust

  Essential Robustness Patterns

  1. Webhook Idempotency (Prevent Duplicate Processing)
  // src/lib/webhook-handler.ts
  class WebhookHandler {
    static async processWebhook(webhookId, eventData) {
      // Check if already processed
      const existing = await ProcessedWebhook.findOne({ webhookId });
      if (existing) {
        return { success: true, message: 'Already processed' };
      }

      // Process in transaction
      const session = await mongoose.startSession();
      try {
        await session.withTransaction(async () => {
          // Mark as processed first
          await ProcessedWebhook.create([{ webhookId, processedAt: new Date() }], { session });

          // Process the actual webhook
          await this.handleSubscriptionCharged(eventData, session);
        });
      } catch (error) {
        // Rollback happens automatically
        throw error;
      } finally {
        await session.endSession();
      }
    }
  }

  2. Retry Mechanism with Exponential Backoff
  // src/lib/retry-handler.ts
  class RetryHandler {
    static async retryWithBackoff(operation, maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          return await operation();
        } catch (error) {
          if (attempt === maxRetries) throw error;

          const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
  }

  // Usage in webhook
  await RetryHandler.retryWithBackoff(() =>
    razorpay.subscriptions.fetch(subscriptionId)
  );

  3. Database Reconciliation Job
  // src/jobs/subscription-sync.ts
  export async function syncSubscriptions() {
    const subscriptions = await Subscription.find({ status: 'active' });

    for (const sub of subscriptions) {
      try {
        const rzpSub = await razorpay.subscriptions.fetch(sub.razorpaySubscriptionId);

        // Check for discrepancies
        if (sub.status !== rzpSub.status) {
          console.log(`Status mismatch: DB=${sub.status}, RZP=${rzpSub.status}`);

          // Update our database to match Razorpay
          await Subscription.findByIdAndUpdate(sub._id, {
            status: rzpSub.status,
            currentPeriodStart: new Date(rzpSub.current_start * 1000),
            currentPeriodEnd: new Date(rzpSub.current_end * 1000),
            lastSyncAt: new Date()
          });
        }
      } catch (error) {
        console.error(`Failed to sync subscription ${sub._id}:`, error);
      }
    }
  }

  // Run daily via cron job
  // 0 2 * * * (every day at 2 AM)

  4. Circuit Breaker Pattern
  // src/lib/circuit-breaker.ts
  class CircuitBreaker {
    constructor(threshold = 5, timeout = 60000) {
      this.failureThreshold = threshold;
      this.timeout = timeout;
      this.failureCount = 0;
      this.lastFailureTime = null;
      this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    }

    async execute(operation) {
      if (this.state === 'OPEN') {
        if (Date.now() - this.lastFailureTime < this.timeout) {
          throw new Error('Circuit breaker is OPEN');
        }
        this.state = 'HALF_OPEN';
      }

      try {
        const result = await operation();
        this.onSuccess();
        return result;
      } catch (error) {
        this.onFailure();
        throw error;
      }
    }

    onSuccess() {
      this.failureCount = 0;
      this.state = 'CLOSED';
    }

    onFailure() {
      this.failureCount++;
      this.lastFailureTime = Date.now();

      if (this.failureCount >= this.failureThreshold) {
        this.state = 'OPEN';
      }
    }
  }

  // Usage
  const razorpayCircuitBreaker = new CircuitBreaker();
  await razorpayCircuitBreaker.execute(() =>
    razorpay.subscriptions.create(subscriptionData)
  );

  Essential Beginner Knowledge for Payment Gateways

  1. Always Verify on Server: Never trust client-side payment confirmation
  2. Use Webhooks: Primary source of payment status updates
  3. Implement Idempotency: Handle duplicate webhooks gracefully
  4. Plan for Failures: Networks fail, APIs timeout, databases lock
  5. Reconcile Regularly: Your DB vs Gateway data can drift
  6. Log Everything: Payment flows need detailed audit trails
  7. Test Edge Cases: Failed payments, refunds, cancellations
  8. Handle Async Nature: Webhooks may arrive before/after user actions

✻ Thinking…

  I have completed all the tasks in my todo list and provided comprehensive answers to all the user's 
  questions. Let me summarize the key points covered:

  1. ✅ Refunds and transaction reversal - Explained Razorpay refund APIs and process
  2. ✅ Edge cases and error handling - Covered webhook timing, duplicates, failed payments
  3. ✅ Razorpay plan creation - Clarified that plans are created in dashboard first
  4. ✅ Subscription ID lifecycle - Corrected misconception about monthly IDs
  5. ✅ RBAC enforcement flow - Detailed backend-to-frontend security flow
  6. ✅ Specific Razorpay APIs - Explained customer, subscription, and payment APIs
  7. ✅ Robust system design - Provided patterns for idempotency, retry, reconciliation

  The user now has a complete understanding of how to implement a robust payment system with RBAC. All their 
  questions have been thoroughly addressed with practical examples and code snippets.

⏺ Summary: Key Takeaways for Robust Payment System

  Critical Success Factors

  1. Security First: Always validate permissions on server, never trust frontend
  2. Idempotency: Handle webhook duplicates to prevent double-processing
  3. Reconciliation: Sync your DB with Razorpay regularly to catch discrepancies
  4. Error Handling: Plan for failures at every step with retry mechanisms
  5. Audit Trail: Log all payment events for debugging and compliance

  Razorpay Mental Model

  - Plans: Created once in dashboard, referenced in code
  - Customers: One per user, stores billing info
  - Subscriptions: One per plan enrollment, handles all recurring billing
  - Webhooks: Primary communication channel for status updates

  Implementation Order

  1. Set up plans in Razorpay dashboard
  2. Build database models and API routes
  3. Implement webhook handling with idempotency
  4. Create frontend payment flow
  5. Add RBAC enforcement at all layers
  6. Build reconciliation and monitoring

  This foundation will handle your ₹100/month Pro subscription robustly and can easily scale to multiple tiers
  later. The key is starting with proper error handling and security patterns from day one.


ADDITIONAL INFO

**1. UI for Initiating a Refund & RBAC**

* **Location in UI**

  * Add a “Request Refund” button on the **Subscription Management** page (e.g. `src/components/subscription/SubscriptionStatus.tsx`).
  * Only visible to users whose subscription status is `active` or `past_due`.
* **RBAC Enforcement**

  * **Frontend (UX‑only)**

    ```tsx
    // SubscriptionStatus.tsx
    const { data: session } = useSession();
    const canRefund = session?.user?.permissions.includes('payment:refund');
    return canRefund 
      ? <Button onClick={openRefundModal}>Request Refund</Button> 
      : null;
    ```
  * **Backend (Security)**

    ```ts
    // src/app/api/payment/refund/route.ts
    import { withRBAC } from '@/lib/rbac';
    export const POST = withRBAC('payment:refund', async (req) => {
      // … refund logic …
    });
    ```
  * By combining auth + RBAC in one middleware (`withRBAC` calls `getServerSession` under the hood), you avoid two DB lookups.

---

**2. “Plan” in Your Flows**

* The **Plan** (`plan_QwuAA00ZJKNHHX`) is a static definition in Razorpay that your **subscription** references.
* In your backend, you keep a local config:

  ```ts
  // src/config/plans.ts
  export const PLANS = {
    PRO_MONTHLY: 'plan_QwuAA00ZJKNHHX'
  };
  ```
* When user clicks “Upgrade to Pro,” you:

  1. Look up `PLANS.PRO_MONTHLY`
  2. Create or fetch a Razorpay customer
  3. Create Razorpay **Subscription** with that plan ID

---

**3. Middleware Combination to Reduce DB Calls**

* **Traditional Flow**:

  ```ts
  // auth.ts
  // 1) authenticate user session → fetch user
  // 2) check user.subscriptionTier → fetch permissions
  ```
* **Combined**:

  ```ts
  // rbac.ts
  export function withRBAC(permission: string) {
    return async (req, res) => {
      const session = await getSession(req);
      const user = await db.users.findOne({ _id: session.user.id }, { 
        projection: { subscriptionTier: 1, permissions: 1 } 
      });
      if (!user.permissions.includes(permission)) 
        return res.status(403).json({ error: 'Forbidden' });
      return handler(req, res, user);
    };
  }
  ```

---

**4. Subscription Management Flow**

```mermaid
flowchart LR
  A[Active Subscription] --> B[Periodic Billing]
  B --> C[Webhook: subscription.charged]
  C --> D[Update DB Status → active]
  D --> E[Feature Access Maintained]
```

---

**5. Feature Access Enforcement**

```mermaid
flowchart LR
  UA[User Action] --> PC[Permission Check]
  PC -->|Allowed| AF[Allow Feature → Show Feature]
  PC -->|Denied| UP[Show Upgrade Prompt]
```

---

**6. Storing `customer_id`**

* **Yes**: store `razorpayCustomerId` on your **Subscription** document (or a separate **Customer** collection).
* **Why?** enables you to re‑use the Razorpay customer for new subscriptions, refunds, payment methods, etc., without creating duplicates.

---

**7. Does the Plan UI Let Users Cancel?**

* Razorpay **Plans** are passive definitions.
* **Cancellation** is done on the **Subscription**, not the Plan.
* In your UI, expose a “Cancel Subscription” button that calls:

  ```ts
  // src/app/api/subscription/cancel/route.ts
  await razorpay.subscriptions.cancel(subscriptionId);
  ```

---

**8. MongoDB Transactions**

* **What?** a way to group multiple read/write operations into an atomic unit.
* **Why Here?** when handling refunds or webhooks you often:

  1. Update **Payment** status to `refunded`
  2. Possibly downgrade **Subscription**/ **User** tier
  3. Insert a **WebhookLog**
* Transactions guarantee that **all** these writes either succeed together or roll back on error, preventing half‑applied state.

---

**9. Retry Mechanism with Exponential Backoff**

* **Tracking Retries**: store a `retryCount` and `nextAttemptAt` on your **Job** document.

  ```js
  // src/models/Job.js
  {
    _id,
    type: 'fetch-status',
    payload: { subscriptionId },
    retryCount: 0,
    nextAttemptAt: Date
  }
  ```
* **Worker Loop** picks jobs where `nextAttemptAt ≤ now`, calls the operation, on error increments `retryCount`, and sets:

  ```js
  nextAttemptAt = now + Math.pow(2, retryCount) * baseDelay;
  ```

---

**10. Database Reconciliation Job**

* **File:** `src/jobs/subscription-sync.ts`
* **Purpose:** periodically (e.g. daily) fetch every active subscription from Razorpay and compare with your DB.
* **Why:** catch discrepancies from missed webhooks, long‑lived network failures, manual plan changes, etc.

---

**11. Circuit Breaker Pattern**

* **File:** `src/lib/circuit-breaker.ts`
* **Concept:** wrap unstable external calls (e.g. Razorpay API) to:

  * **OPEN** the circuit after N failures → immediately fail new calls for a “cool‑down”
  * **HALF‑OPEN** after timeout → try one request to see if service recovered
  * **CLOSED** on success → normal operation
* **Benefit:** prevents cascading failures in your app when Razorpay is down or flapping.

---

> **Putting It All Together:**
>
> * **UI** hosts “Refund” & “Cancel” buttons on the Subscription page (guarded by RBAC via one combined auth+permission middleware).
> * **Backend** stores `customer_id` in your Subscription; uses transactions to atomically update Payments, Subscriptions, Users, and WebhookLogs.
> * **Reliability** is ensured by:
>
>   * **Retry jobs** with exponential backoff (tracked in Job docs)
>   * **Reconciliation cron** (`subscription-sync.ts`)
>   * **Circuit Breaker** around all Razorpay calls
> * **Flows**:
>
>   1. **Subscription Management** → Automatic billing + webhooks
>   2. **Feature Enforcement** → Multi‑layer RBAC checks

This architecture minimizes DB calls, centralizes security, and ensures robustness from payments through refunds, with clear UI triggers and backend patterns.
